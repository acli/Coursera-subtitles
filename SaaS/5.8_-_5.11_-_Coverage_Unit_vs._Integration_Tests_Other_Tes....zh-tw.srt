1
00:00:00,005 --> 00:00:01,009
過去幾節課裡

2
00:00:01,009 --> 00:00:03,003
我們花了些時間

3
00:00:03,003 --> 00:00:05,008
談論不同的測試方法

4
00:00:05,008 --> 00:00:08,002
關於單元測試還有整合測試

5
00:00:08,002 --> 00:00:10,000
我們也談到各位如何使用RSpec

6
00:00:10,000 --> 00:00:12,004
真正將你想測試的程式碼分開

7
00:00:12,004 --> 00:00:14,008
如同作業三和其他部份

8
00:00:14,008 --> 00:00:18,001
我們也做了BDD

9
00:00:18,001 --> 00:00:20,006
我們也使用Cucumber把使用者的流程

10
00:00:20,006 --> 00:00:22,009
轉變成基本、整合並合理的測試

11
00:00:22,009 --> 00:00:25,006
所以，你已經看到不同層次的測試

12
00:00:25,006 --> 00:00:27,006
為了達成一些目標

13
00:00:27,006 --> 00:00:29,009
我們站遠點綜觀看看

14
00:00:29,009 --> 00:00:33,000
並將這些事情一起來看

15
00:00:33,000 --> 00:00:34,009
這些上課的東西涵蓋

16
00:00:34,009 --> 00:00:37,000
課本上三到四個章節

17
00:00:37,000 --> 00:00:39,006
我在這邊只是稍微提到而已

18
00:00:39,006 --> 00:00:41,004
所以延伸出一個問題

19
00:00:41,004 --> 00:00:43,002
我想你們也都會有這個問題

20
00:00:43,002 --> 00:00:44,005
你們做作業時

21
00:00:44,005 --> 00:00:45,006
會覺得：「多少測試才夠呢？」

22
00:00:45,006 --> 00:00:48,004
難過的是

23
00:00:48,004 --> 00:00:51,000
之後你們在業界問這個問題

24
00:00:51,000 --> 00:00:52,001
答案是非常簡單的

25
00:00:52,001 --> 00:00:53,001
「關於這個問題，我們有產品的結案日期，

26
00:00:53,001 --> 00:00:54,009
所以在結案日期前能做的測試

27
00:00:54,009 --> 00:00:56,006
即足以。」

28
00:00:56,006 --> 00:00:58,001
也就是有多少時間就做多少

29
00:00:58,001 --> 00:01:00,000
這其實有點顛倒了

30
00:01:00,000 --> 00:01:01,001
顯然不是很好

31
00:01:01,001 --> 00:01:02,005
其實你們可以做的更好，對吧？

32
00:01:02,005 --> 00:01:03,007
這邊有些靜態的測量

33
00:01:03,007 --> 00:01:06,000
像是程式裡有多少程式碼

34
00:01:06,000 --> 00:01:08,002
多少行測試用的程式碼等

35
00:01:08,002 --> 00:01:10,002
這在業界並不常見

36
00:01:10,002 --> 00:01:12,006
在完整測試的程式裡

37
00:01:12,006 --> 00:01:14,005
幾行是測試用的

38
00:01:14,005 --> 00:01:17,007
遠遠超過本來程式碼的行數

39
00:01:17,007 --> 00:01:19,007
所以倍增的量也是常見的

40
00:01:19,007 --> 00:01:21,008
我想對於排序而言

41
00:01:21,008 --> 00:01:23,002
研究程式碼或類別運作等

42
00:01:23,002 --> 00:01:26,008
1.5倍也非不合理

43
00:01:26,008 --> 00:01:30,000
所以測試用的程式碼有1.5倍這麼多

44
00:01:30,000 --> 00:01:32,002
跟你的應用程式一樣

45
00:01:32,002 --> 00:01:34,002
在很多的生產系統裡

46
00:01:34,002 --> 00:01:35,002
是真正需要測試的

47
00:01:35,002 --> 00:01:36,009
需求比其他更高

48
00:01:36,009 --> 00:01:38,001
所以也許可以用另一個方式來問這個問題，而不是用

49
00:01:38,001 --> 00:01:39,004
「需要多少測試呢？」

50
00:01:39,004 --> 00:01:42,004
而是「我現在做的測試有多完整？」

51
00:01:42,004 --> 00:01:44,003
「有多徹底？」

52
00:01:44,003 --> 00:01:45,005
這個學期後

53
00:01:45,005 --> 00:01:46,005
Sen教授會談論一點有關

54
00:01:46,005 --> 00:01:48,001
比較正規的方式

55
00:01:48,001 --> 00:01:50,008
和最先進的測試和除錯方法

56
00:01:50,008 --> 00:01:52,006
但是我們講了這麼多

57
00:01:52,006 --> 00:01:54,000
你已經知道的

58
00:01:54,000 --> 00:01:57,007
是一些軟體測試的基本概念

59
00:01:57,007 --> 00:01:59,005
我也許會說

60
00:01:59,005 --> 00:02:01,000
我們把正規的測試都已經都說過了

61
00:02:01,000 --> 00:02:03,000
但是大的系統上不這麼用

62
00:02:03,000 --> 00:02:05,003
我個人的觀點是

63
00:02:05,003 --> 00:02:07,000
這只對一部分

64
00:02:07,000 --> 00:02:09,001
我想有許多特殊的場合裡

65
00:02:09,001 --> 00:02:10,005
特別在測試和除錯狀況

66
00:02:10,005 --> 00:02:12,008
這些正規測試方法的確可以加快不少

67
00:02:12,008 --> 00:02:15,007
在這方面 Koushik Sen 是個領導先驅

68
00:02:15,007 --> 00:02:17,009
所以之後你們都有很好的機會可以了解更多

69
00:02:17,009 --> 00:02:21,004
不過現在我講的就像是麵包和奶油

70
00:02:21,004 --> 00:02:22,007
只是涵蓋性測試 (coverage measurement)

71
00:02:22,007 --> 00:02:24,004
就像是輪胎碰觸到地面時

72
00:02:24,004 --> 00:02:26,002
假如你真的需要時

73
00:02:26,002 --> 00:02:28,006
你已了解如何怎麼去評估

74
00:02:28,006 --> 00:02:29,005
那麼哪些事基礎呢？

75
00:02:29,005 --> 00:02:30,007
這邊有個很簡單的類別庫可以直接用

76
00:02:30,007 --> 00:02:32,009
試著用不同的方法來量測

77
00:02:32,009 --> 00:02:34,008
我們的測試可涵蓋多少程式範圍

78
00:02:34,008 --> 00:02:36,006
這邊有些不同的程度差異

79
00:02:36,006 --> 00:02:37,008
以不同的字彙來說的話

80
00:02:37,008 --> 00:02:40,007
這不像是所有的程式部門都通用

81
00:02:40,007 --> 00:02:42,006
但是是較通常使用的字彙

82
00:02:42,006 --> 00:02:43,006
是書本裡面會用的

83
00:02:43,006 --> 00:02:44,006
我們談到 S0

84
00:02:44,006 --> 00:02:47,004
意思是你呼叫每個方法一次

85
00:02:47,004 --> 00:02:50,004
所以你呼叫 foo 在呼叫 bar 時，就完成了

86
00:02:50,004 --> 00:02:52,001
這就是 S0 coverage：這不是全盤的涵蓋

87
00:02:52,001 --> 00:02:54,006
而是比較限制性的

88
00:02:54,006 --> 00:02:56,001
而 S1 是可以呼叫每一個方法

89
00:02:56,001 --> 00:02:57,002
只要可以呼叫都去呼叫

90
00:02:57,002 --> 00:02:58,008
這什麼意思？

91
00:02:58,008 --> 00:03:00,000
舉例來說

92
00:03:00,000 --> 00:03:01,001
只呼叫 bar 不夠

93
00:03:01,001 --> 00:03:02,009
你要先確定你一定會呼叫 bar 至少一次

94
00:03:02,009 --> 00:03:05,005
在整個過程裡

95
00:03:05,005 --> 00:03:07,001
如同真的會呼叫一次

96
00:03:07,001 --> 00:03:10,003
可以是從任何外部函數呼叫

97
00:03:10,003 --> 00:03:12,008
C0 是 SimpleCov 所測量的

98
00:03:12,008 --> 00:03:15,009
(你已經知道 SimpleCov 且實際做過)

99
00:03:15,009 --> 00:03:18,005
基本上你執行所有的程式碼

100
00:03:18,005 --> 00:03:20,000
在你的程式碼全部都做過一次

101
00:03:20,000 --> 00:03:22,004
但這邊要小心一下

102
00:03:22,004 --> 00:03:25,005
條件運算只被算一次而已

103
00:03:25,005 --> 00:03:28,009
所以假如發生條件判斷例如執行了 "if"

104
00:03:28,009 --> 00:03:31,007
只要程式碼分支有執行到

105
00:03:31,007 --> 00:03:33,003
你已經執行了 "if" 陳述句

106
00:03:33,003 --> 00:03:35,006
所以 C0 仍然只是涵蓋比較表層的範圍

107
00:03:35,006 --> 00:03:37,002
但是我們繼續看

108
00:03:37,002 --> 00:03:39,002
你想看到的應該像是

109
00:03:39,002 --> 00:03:41,007
假如 C0 程度這種比較不好的涵蓋測試

110
00:03:41,007 --> 00:03:44,000
你真的只能得到比較差的涵蓋範圍

111
00:03:44,000 --> 00:03:46,000
所以你不像是

112
00:03:46,000 --> 00:03:47,003
在做這種簡單的表層測試

113
00:03:47,003 --> 00:03:50,000
這種測試大概沒什麼用

114
00:03:50,000 --> 00:03:51,009
C1 則是更近一步

115
00:03:51,009 --> 00:03:53,007
可以這麼說

116
00:03:53,007 --> 00:03:55,001
必須把所有分支雙方向測試

117
00:03:55,001 --> 00:03:56,006
所以當我們在執行 "if" 陳述句

118
00:03:56,006 --> 00:03:58,006
就必須確保

119
00:03:58,006 --> 00:03:59,009
"if x" 這個部分執行到

120
00:03:59,009 --> 00:04:05,001
"if not x"這個部分也至少執行一次，才符合 C1

121
00:04:05,001 --> 00:04:08,003
可以理解為 decision coverage

122
00:04:08,003 --> 00:04:09,006
意思是：我們如果想要...

123
00:04:09,006 --> 00:04:12,003
假如我們發現 "if" 陳述句

124
00:04:12,003 --> 00:04:13,008
裡面包含不只一種陳述句

125
00:04:13,008 --> 00:04:15,007
我們必須確保每個陳述句

126
00:04:15,007 --> 00:04:17,009
都可以雙向評估

127
00:04:17,009 --> 00:04:19,006
換句話說

128
00:04:19,006 --> 00:04:22,004
如果 "if" 不執行

129
00:04:22,004 --> 00:04:24,003
就要確保 fail 至少一次

130
00:04:24,003 --> 00:04:26,004
因為 y 至少一次是 false ， 又因為 z 是 false

131
00:04:26,004 --> 00:04:28,008
任何陳述句

132
00:04:28,008 --> 00:04:31,002
都是獨立的依條件改變結果

133
00:04:31,002 --> 00:04:34,004
都必須能夠雙向測試

134
00:04:34,004 --> 00:04:36,000
然後

135
00:04:36,000 --> 00:04:38,005
很多人了解

136
00:04:38,005 --> 00:04:41,002
但也有人反對，認為這麼做到底有沒有意義

137
00:04:41,002 --> 00:04:42,008
認為每個路徑都走過

138
00:04:42,008 --> 00:04:45,005
顯然有困難度

139
00:04:45,005 --> 00:04:48,003
因為所有條件都考慮會造成量呈指數倍數的增加

140
00:04:48,003 --> 00:04:53,000
通常很難去評估

141
00:04:53,000 --> 00:04:55,003
每個路徑都測試的話

142
00:04:55,003 --> 00:04:57,000
這邊可以用比較正規的方法來做

143
00:04:57,000 --> 00:04:58,008
讓你們知道洞在哪

144
00:04:58,008 --> 00:05:01,003
但是最根本的是

145
00:05:01,003 --> 00:05:03,000
在大部分的商業軟體公司裡

146
00:05:03,000 --> 00:05:04,008
對於 C2 有多少價值的觀念

147
00:05:04,008 --> 00:05:06,006
還不太一致

148
00:05:06,006 --> 00:05:08,006
比起 C0 或 C1

149
00:05:08,006 --> 00:05:10,001
所以我認為要看我們的程式的用途

150
00:05:10,001 --> 00:05:11,006
你有了這個想法

151
00:05:11,006 --> 00:05:13,001
了解你的測試涵蓋多少資訊

152
00:05:13,001 --> 00:05:16,004
SimpleCov 在 Ruby 裡有些優勢

153
00:05:16,004 --> 00:05:18,000
讓你們可以做 C0 測試

154
00:05:18,000 --> 00:05:19,006
有很好的報導指出

155
00:05:19,006 --> 00:05:21,002
大抵上而言我們

156
00:05:21,002 --> 00:05:22,009
可以依據檔案大小來看

157
00:05:22,009 --> 00:05:24,009
你可以看看你的涵蓋範圍

158
00:05:24,009 --> 00:05:27,001
我覺得

159
00:05:27,001 --> 00:05:31,001
這是個很好的開始

160
00:05:31,001 --> 00:05:33,007
我們已經看了些好用的測試後

161
00:05:33,007 --> 00:05:37,001
往回退一步宏觀的看

162
00:05:37,001 --> 00:05:38,009
不同的測試哪裡不同

163
00:05:38,009 --> 00:05:40,007
我們到現在已經了解的部分

164
00:05:40,007 --> 00:05:42,003
如果使用不同的測試

165
00:05:42,003 --> 00:05:43,008
各自的缺點又是什麼

166
00:05:43,008 --> 00:05:47,001
我們已經看過單一類別和方法的程度

167
00:05:47,001 --> 00:05:50,000
我們用 RSpec 大量使用了 mocking 和 stubbing 測試
