1
00:00:00,005 --> 00:00:01,009
過去幾節課裡

2
00:00:01,009 --> 00:00:03,003
我們花了些時間

3
00:00:03,003 --> 00:00:05,008
談論過不同的測試方法

4
00:00:05,008 --> 00:00:08,002
也談論過單元測試和整合測試的異同

5
00:00:08,002 --> 00:00:10,000
我們也講解過如何使用RSpec

6
00:00:10,000 --> 00:00:12,004
真正將你想測試的程式碼分開

7
00:00:12,004 --> 00:00:14,008
也因為作業三和其他部份的關係

8
00:00:14,008 --> 00:00:18,001
我們也研究過BDD

9
00:00:18,001 --> 00:00:20,006
當中，我們基本上就是使用Cucumber把使用者的流程

10
00:00:20,006 --> 00:00:22,009
轉變成整合測試和合格測試 (acceptance test)

11
00:00:22,009 --> 00:00:25,006
你已經看到不同層次的測試

12
00:00:25,006 --> 00:00:27,006
所以，這節課的目標基本上只是簡單的總結一下而已

13
00:00:27,006 --> 00:00:29,009
就是說，我們站遠點綜觀看看

14
00:00:29,009 --> 00:00:33,000
並將這些事情一起來看

15
00:00:33,000 --> 00:00:34,009
基本上，這節課的內容將會涵蓋

16
00:00:34,009 --> 00:00:37,000
課本上三到四個章節

17
00:00:37,000 --> 00:00:39,006
我在這邊只是稍微提到而已

18
00:00:39,006 --> 00:00:41,004
好了，有一個問題是常常出現的

19
00:00:41,004 --> 00:00:43,002
我想你們也都會有這個問題

20
00:00:43,002 --> 00:00:44,005
因為你們也有做作業

21
00:00:44,005 --> 00:00:45,006
問題就是：「多少測試才夠呢？」

22
00:00:45,006 --> 00:00:48,004
難過的是

23
00:00:48,004 --> 00:00:51,000
如果你們在業界問這個問題

24
00:00:51,000 --> 00:00:52,001
答案是非常簡單的

25
00:00:52,001 --> 00:00:53,001
「關於這個問題，我們有產品的結案日期，

26
00:00:53,001 --> 00:00:54,009
所以在結案日期前能做的測試

27
00:00:54,009 --> 00:00:56,006
即足以。」

28
00:00:56,006 --> 00:00:58,001
也就是有多少時間就做多少

29
00:00:58,001 --> 00:01:00,000
這其實有點顛倒了

30
00:01:00,000 --> 00:01:01,001
顯然不是很好

31
00:01:01,001 --> 00:01:02,005
其實你們可以做的更好，對吧？

32
00:01:02,005 --> 00:01:03,007
這邊有些靜態的測量

33
00:01:03,007 --> 00:01:06,000
像是程式裡有多少程式碼

34
00:01:06,000 --> 00:01:08,002
多少行測試用的程式碼等

35
00:01:08,002 --> 00:01:10,002
另外，在業界並不罕見的是

36
00:01:10,002 --> 00:01:12,006
針對測試完整的程式而言

37
00:01:12,006 --> 00:01:14,005
測試用的程式碼的行數

38
00:01:14,005 --> 00:01:17,007
往往是遠遠超過本來程式碼的行數的

39
00:01:17,007 --> 00:01:19,007
甚至，倍增的量也是常見的

40
00:01:19,007 --> 00:01:21,008
我想，即使甚至是

41
00:01:21,008 --> 00:01:23,002
研究程式碼，甚至是習作等

42
00:01:23,002 --> 00:01:26,008
1.5倍也非不合理

43
00:01:26,008 --> 00:01:30,000
也就是說，測試用的程式碼

44
00:01:30,000 --> 00:01:32,002
有應用程式碼的1.5倍

45
00:01:32,002 --> 00:01:34,002
在很多實作的系統裡

46
00:01:34,002 --> 00:01:35,002
就是說是真正需要測試的

47
00:01:35,002 --> 00:01:36,009
測試程式碼對應用程式碼的比率，甚至比這個更高

48
00:01:36,009 --> 00:01:38,001
所以也許可以用另一個較好的方式來問這個問題

49
00:01:38,001 --> 00:01:39,004
就是，與其問「需要多少測試呢？」

50
00:01:39,004 --> 00:01:42,004
不如問「我現在做的測試有多完整？」

51
00:01:42,004 --> 00:01:44,003
「有多徹底？」

52
00:01:44,003 --> 00:01:45,005
這個學期的後半部

53
00:01:45,005 --> 00:01:46,005
Sen教授將會

54
00:01:46,005 --> 00:01:48,001
對正規方法 (formal methods) 作一個簡略的介紹

55
00:01:48,001 --> 00:01:50,008
並談論一下測試和除錯方法的最新進展

56
00:01:50,008 --> 00:01:52,006
但是，對於這點，現在我們還是可以略提一二的

57
00:01:52,006 --> 00:01:54,000
就是說，基於你們已經知道的，我們還是可以略提

58
00:01:54,000 --> 00:01:57,007
一些有關測試涵蓋率 (test coverage) 的基本概念

59
00:01:57,007 --> 00:01:59,005
我也許會說

60
00:01:59,005 --> 00:02:01,000
事實上我們也一直說

61
00:02:01,000 --> 00:02:03,000
正規方法在大的系統上基本上根本是沒用的

62
00:02:03,000 --> 00:02:05,003
不過，我個人的觀點是

63
00:02:05,003 --> 00:02:07,000
這個說法以前的確很對，但現在已經不太對了

64
00:02:07,000 --> 00:02:09,001
我想，有許多特殊的場合裡

65
00:02:09,001 --> 00:02:10,005
特別在測試和除錯方面

66
00:02:10,005 --> 00:02:12,008
正規測試已經獲得了很大的進展

67
00:02:12,008 --> 00:02:15,007
在這方面 Koushik Sen 是個領導先驅

68
00:02:15,007 --> 00:02:17,009
所以，之後你們都有機會可以了解更多

69
00:02:17,009 --> 00:02:21,004
不過現在我講的，是一些可以說是很實際的東西

70
00:02:21,004 --> 00:02:22,007
就是測試涵蓋率的測量 (coverage measurement)

71
00:02:22,007 --> 00:02:24,004
因為這就是實際情況

72
00:02:24,004 --> 00:02:26,002
換句話說，假如有人要評估你

73
00:02:26,002 --> 00:02:28,006
就是說在真正的工作時有人要評估你，這就是實際情況

74
00:02:28,006 --> 00:02:29,005
那麼，有什麼基礎的東西呢？

75
00:02:29,005 --> 00:02:30,007
讓我給你一個很簡單的類別

76
00:02:30,007 --> 00:02:32,009
來講解有什麼不同的方法來量測

77
00:02:32,009 --> 00:02:34,008
我們的測試可涵蓋多少程式範圍

78
00:02:34,008 --> 00:02:36,006
這邊有些不同的程度差異

79
00:02:36,006 --> 00:02:37,008
以不同的字彙來說的話

80
00:02:37,008 --> 00:02:40,007
這不像是所有的程式部門都通用

81
00:02:40,007 --> 00:02:42,006
但是有一套較通常使用的字彙

82
00:02:42,006 --> 00:02:43,006
是我們的課本裡面用的

83
00:02:43,006 --> 00:02:44,006
就是，我們談到 S0

84
00:02:44,006 --> 00:02:47,004
意思是你呼叫每個方法一次

85
00:02:47,004 --> 00:02:50,004
就是說，你呼叫 foo，然後呼叫 bar，就完成了

86
00:02:50,004 --> 00:02:52,001
這就是 S0 coverage，不是怎麼的全盤

87
00:02:52,001 --> 00:02:54,006
比較嚴謹的 S1

88
00:02:54,006 --> 00:02:56,001
基本上就是，我們呼叫了每一個方法

89
00:02:56,001 --> 00:02:57,002
而且是只要可以呼叫某個方法的地方都去呼叫那個方法

90
00:02:57,002 --> 00:02:58,008
這什麼意思？

91
00:02:58,008 --> 00:03:00,000
舉例來說

92
00:03:00,000 --> 00:03:01,001
只呼叫 bar 不夠

93
00:03:01,001 --> 00:03:02,009
你要先確定你一定會

94
00:03:02,009 --> 00:03:05,005
在這裏呼叫 bar 至少一次

95
00:03:05,005 --> 00:03:07,001
除此以外，還要確定

96
00:03:07,001 --> 00:03:10,003
任何可以呼叫 bar 的外部函數都要呼叫 bar 一次

97
00:03:10,003 --> 00:03:12,008
至於 SimpleCov 所測量的 C0

98
00:03:12,008 --> 00:03:15,009
(你們當中已經設定好 SimpleCov 且實際做過的人啊)

99
00:03:15,009 --> 00:03:18,005
基本上就是表示你執行所有的程式碼

100
00:03:18,005 --> 00:03:20,000
在你的程式碼全部都做過一次

101
00:03:20,000 --> 00:03:22,004
但這邊要小心一下

102
00:03:22,004 --> 00:03:25,005
條件運算只被算一次而已

103
00:03:25,005 --> 00:03:28,009
所以假如發生條件判斷例如執行了 "if"

104
00:03:28,009 --> 00:03:31,007
只要程式碼分支有執行到

105
00:03:31,007 --> 00:03:33,003
你已經執行了 "if" 陳述句

106
00:03:33,003 --> 00:03:35,006
所以 C0 仍然只是涵蓋比較表層的範圍

107
00:03:35,006 --> 00:03:37,002
但是我們將會看到

108
00:03:37,002 --> 00:03:39,002
對 C0 涵蓋率的正確理解，其實是這樣的：

109
00:03:39,002 --> 00:03:41,007
假如 C0 程度的涵蓋率你也測出了不好的涵蓋率

110
00:03:41,007 --> 00:03:44,000
你的測試涵蓋率就真的是非常非常的差了

111
00:03:44,000 --> 00:03:46,000
因為

112
00:03:46,000 --> 00:03:47,003
你如果連這種簡單的表層測試也達不到

113
00:03:47,003 --> 00:03:50,000
你的測試大概很有問題了

114
00:03:50,000 --> 00:03:51,009
C1 則是更進一步

115
00:03:51,009 --> 00:03:53,007
可以這麼說

116
00:03:53,007 --> 00:03:55,001
必須把所有分支雙方向測試

117
00:03:55,001 --> 00:03:56,006
所以當我們在執行 "if" 陳述句

118
00:03:56,006 --> 00:03:58,006
就必須確保

119
00:03:58,006 --> 00:03:59,009
"if x" 這個部分執行到

120
00:03:59,009 --> 00:04:05,001
"if not x"這個部分也至少執行一次，才符合 C1

121
00:04:05,001 --> 00:04:08,003
如果要再進一步，可以再加入 decision coverage

122
00:04:08,003 --> 00:04:09,006
意思是：我們如果想要...

123
00:04:09,006 --> 00:04:12,003
假如我們發現 "if" 陳述句

124
00:04:12,003 --> 00:04:13,008
裡面包含不只一種陳述句

125
00:04:13,008 --> 00:04:15,007
我們必須確保每個陳述句

126
00:04:15,007 --> 00:04:17,009
都可以雙向評估

127
00:04:17,009 --> 00:04:19,006
換句話說

128
00:04:19,006 --> 00:04:22,004
如果 "if" 不執行

129
00:04:22,004 --> 00:04:24,003
就要確保 fail 至少一次

130
00:04:24,003 --> 00:04:26,004
因為 y 至少一次是 false ， 又因為 z 是 false

131
00:04:26,004 --> 00:04:28,008
任何陳述句

132
00:04:28,008 --> 00:04:31,002
都是獨立的依條件改變結果

133
00:04:31,002 --> 00:04:34,004
都必須能夠雙向測試

134
00:04:34,004 --> 00:04:36,000
然後

135
00:04:36,000 --> 00:04:38,005
有一件事很多人都希望做到

136
00:04:38,005 --> 00:04:41,002
但沒有共識說這麼做到底有沒有意義

137
00:04:41,002 --> 00:04:42,008
就是每個路徑都走過

138
00:04:42,008 --> 00:04:45,005
顯然，這是有困難度的

139
00:04:45,005 --> 00:04:48,003
因為所有條件都考慮會造成量呈指數倍數的增加

140
00:04:48,003 --> 00:04:53,000
況且，通常都很難去評估

141
00:04:53,000 --> 00:04:55,003
究竟是不是每個路徑都已經測試

142
00:04:55,003 --> 00:04:57,000
針對這些困難的正規方法，是有的

143
00:04:57,000 --> 00:04:58,008
它們可以讓你們知道洞在哪

144
00:04:58,008 --> 00:05:01,003
但是最根本的是

145
00:05:01,003 --> 00:05:03,000
在大部分的商業軟體公司裡

146
00:05:03,000 --> 00:05:04,008
對於 C2 有多少價值的觀念

147
00:05:04,008 --> 00:05:06,006
還不太一致

148
00:05:06,006 --> 00:05:08,006
就是說，C2 比起 C0 或 C1 究竟有多少價值，還是沒有一個共識

149
00:05:08,006 --> 00:05:10,001
所以，我認為，這個課程的用意是

150
00:05:10,001 --> 00:05:11,006
讓你們了解

151
00:05:11,006 --> 00:05:13,001
怎樣使用測試涵蓋率的資訊

152
00:05:13,001 --> 00:05:16,004
SimpleCov 利用 Ruby 中的一些功能

153
00:05:16,004 --> 00:05:18,000
讓你們可以做 C0 測試

154
00:05:18,000 --> 00:05:19,006
也有很好的報表

155
00:05:19,006 --> 00:05:21,002
給我們的資訊

156
00:05:21,002 --> 00:05:22,009
大抵上而言是逐檔案，逐程式行的資訊

157
00:05:22,009 --> 00:05:24,009
你可以看看你的涵蓋範圍

158
00:05:24,009 --> 00:05:27,001
我覺得

159
00:05:27,001 --> 00:05:31,001
這是個很好的開始

160
00:05:31,001 --> 00:05:33,007
我們已經看了不同種類的測試後

161
00:05:33,007 --> 00:05:37,001
往回退一步宏觀的看

162
00:05:37,001 --> 00:05:38,009
我們實際看過的不同的測試

163
00:05:38,009 --> 00:05:40,007
究竟有那幾種？

164
00:05:40,007 --> 00:05:42,003
如果使用不同的測試

165
00:05:42,003 --> 00:05:43,008
各自的缺點又是什麼？

166
00:05:43,008 --> 00:05:47,001
我們已經看過單一類別和方法的程度

167
00:05:47,001 --> 00:05:50,000
我們用 RSpec 大量使用了 mocking 和 stubbing 測試
